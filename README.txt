`			-*- mode: xnotes -*-

    
    u-pki: A selfcontained script to maintain a public key
    infrastructure easily
    ~~~~~~~~~~~~~~~~~~~~~
    
*   About
    =====
    
    u-pki is a selfcontained skript to maintain a public key
    infrastrukture. u-pki can be used to operate a CA (that means
    receiving certificate requests, signing them and sending the
    certificates back). u-pki can also be used to manage ssl based
    services definition, generate keys and send certificate requests
    for those services to the CA and recieve signed certificates from
    the CA.
    
    Since u-pki is self contained, you can operate your CA or
    your ssl services provider on any Unix machine that has openssl
    installed.
    
    For step by step instructions see section "Sample Sessions" below.
    
    For information about u-pki limiation and weaknesses, see section
    "Limitations" below.    
    
    
*   Licensing
    ---------

    u-pki is free software; you can redistribute it and/or modify it
    under the terms of the GNU General Public License version 3.0 as
    published by the Free Software Foundation (no later version).

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
    02110-1301 USA.
    
*   How to use
    ----------
    
    See the sample sessions in the next section.
    
    NOTE: Since u-pki does not encrypt the keys it generates (by
    design) one should use it only with encrypted file systems if
    you're serious and do not assume physical security of your
    computing system.

    
*   Sample session(s)
    -----------------
    
    In u-pki you always operate in one of 2 possible roles:
    
      - Either you operate an organisation (or organizational unit)
        providing ssl-services (e.g. the IT-Department of a company
        that provides a https-Server, a secure imap server and a TLS
        capable smpt server), this is also called a service operator,
    
      - Or you operate a root CA, receiving and signing certificate
        requests and sending certificates back to the client
        organisation.
    
    ATM the transport of requests and then certificates between CA and
    organisations using certificates (service operators) is - ATM -
    rather simple. The requests are copied into a spool directory by
    the service operator, from where they are fetched by the CA,
    signed and the certificate put back into a (possibly different)
    spool directory from where they are fetched in turn by the SSL
    service operators.
    
    This method allows things to be set up in a way that the spool
    directory would be a removable media (USB stick) and to operate
    the CA on an isolated machine without any connection to the
    network, thus circumventing many security issues (see below under
    paranoid setup).
    
**  Scenario
    
    The following session protocols will show how a new CA is
    generated by a company called "Frobnicate Inc", how a new service
    database ist generated by "Argoonics Foundation", how "Argoonics
    Foundation" requests a new certificate for their web server, how
    "Frobnicate Inc" signs this certificate and sends it back.
    
    In line we'll also try to adress some verification issues
    pertinent to the procedure.
    
**  Setting up a new CA
    
    CAs are kept in directories in a unix file system. All state and
    configuration data of the CA are kept in this directory. It is
    possible to completely backup the CA by backing up this
    directory.

    The CA directory must be initialized with 'u-pki ca new ...':

      | $> u-pki ca new MyCA
      |
      | CA has been initialized. Now change directory to 'MyCA' and
      | run 'u-pki ca new-key <days>' to generate a new CA key which
      | is valid <days> days. Optionally link 'inbox' and 'outbox'
      | directory (e.g. to an USB stick).
      | 
      | $>

    The 'ca new' command also writes a configuration file to the CA
    directory which needs to be completed:
    
      | $> cd MyCA
      | $> emacs CA/CA.cnf
    
    One will find a section like the following in CA/CA.cnf:
      
    Places where information describing the CA should be filled in,
    are marked with <<insert ... here>>. Some of those lines have been
    commented out and need to be commented in.
        
      > commonName       = <<insert email or ident text here>>
      > emailAddress     = <<insert email address here>>
      > organizationName = <<insert organization name here>>
    
    Note, that for u-pki and the certificates to work, only the
    organizationName needs to be given for the CA.
    
    In our sample session the Frobnicate CA operator adds the
    following information:
    
      > commonName       = Frobnicate CA
      > emailAddress     = ca@frobnicate.no
      > organizationName = Frobnicate Inc

    Additionally one might want to change the default_days entry,
    which specifies for how many days to sign certificates.
        
      > default_days     = 3650
    
    Also one needs to link the directories from where to take the
    certificate requests and to which to copy the signed certificates
    to 'inbox' and 'outbox' in the CA top level directory.
    
      | $> ln -s /media/usb1 inbox
      | $> ln -s /media/usb1 outbox
      | $>

    Finally a new root CA key and certificate need to be created:
    
      | $> u-pki ca new-key 4000

      | Generating a 2048 bit RSA private key
      | ...............+++
      | ......................................................................+++
      | writing new private key to 'CA/CA_Frobnicate-Inc_20090823_003411.key'    

    The key needs to be kept secure: Those who have this key can sign
    certificates on behalf of the CA. 
    
    On the other side, the corresponding certificate (in the same
    place andwith the same basename as the key, but ending on .crt)
    should be proliferated as far as possible: A client accessing a
    service using a certificate signed by the CA needs to import and
    trust the root certificate generated at the same time as the CA
    key.
    
    [TBI] For convenience the root certificate is copied into the
    spool every time certificates are shipped.
    
    
**  Setting up a new organization
    
    As with the CA, all date pertaining to the SSL provider
    organisation is being kept in a single directory.  This data is,
    e.g. configuration files for generating new certificate requests,
    the requests themselves and recieved certificates.
    
    A new SSL provider organization must be initialzed with the
    command 'u-pki org new ...'.
        
      | $> u-pki org new MyOrg
      |  
      | Org has been initialized.  You should now edit Org/Org.cnf.
      | Optionally link 'inbox' and 'outbox' directory (e.g. to an USB
      | stick).
    
    Here too, u-pkiu produces a default configuration file to describe
    the default features of request issued by your organization. The
    configuration file needs to be completed:
    
      | $> emacs Org/Org.cnf    
    
    Again '<insert ...>' marks points whre to insert information.
    
      > commonName          = <<insert email or ident text here>> # only when defining entity
      > 
      > # 0.subjectAltName  = ...
      > # 1.subjectAltName  = ...
      > 
      > emailAddress        = <<insert email address here>>
      > organizationName    = <<insert organization name here>>

    On should probably at least fill in organizationName and perhaps
    default_days (which determines for how many days of validity we
    should ask when generating a new request.
    
    On bthe other side you should leave open all information that will
    later be specific for the service in question (e.g. commonName,
    which in the case of server is just the DNS name of the server).
    
      > commonName          = <<insert email or ident text here>> # only when defining entity
      > 
      > # 0.subjectAltName  = ...
      > # 1.subjectAltName  = ...
      > 
      > emailAddress        = info@argoonics.no
      > organizationName    = Argoonics Foundation
    
    Note, that Org/Org.cnf is not involved directly in generatin
    certificate requests. Instead Org/Org.cnf is used as template when
    generating the service specific configuration files.

    Also one needs to link the directories into which to copy the
    certificate requests and from which to fetch the signed
    certificates to 'inbox' and 'outbox' in the organization top level
    directory.
    
      | $> ln -s /media/usb1 inbox
      | $> ln -s /media/usb1 outbox
      | $>
    

**  Creating a new entity and requesting keys (Org) 

    Before one can request a cerificate, one needs to create the
    service (as a configuration file) for which to request the
    certificate. This has the advantage that it is easy to request a
    new certficate with the same properties later when the former
    certificate has expired.
    
    An ssl service is called an "entity" in u-pki. This is due to the
    fact that x509 certificates could also be used to sign and encrypt
    e-mail (with SMIME) and certificates used for this could also be
    managed with u-pki. The "entity" in this case would be the person
    or role holding the e-mail adress (and the encryption key) rather
    than an automated server (like a web server).

    New entities should be created with 'u-pki org new-ent ...'. In
    the following fragment the "Argoonics Foundation" administrator
    creates their web server as entity:
 
      | $> u-pki org new-ent www
      |
      | Entity www has been created.  You should now edit
      | Ent/www.cnf.

    Ent/Ent.cnf must be edited to supply the necessary information
    describing the entity:
    
      | $> emacs Ent/www.cnf    
    
    The minimum required information for most Services is the
    commonName which must be set to the DNS-Name of the server
    carrying the service.
    
      > commonName          = <<insert email or ident text here>> # only when defining entity
      > 
      > # 0.subjectAltName  = ...
      > # 1.subjectAltName  = ...
    
    If your web server should be adressable under various names (as is
    the case with e.g. virtual web servers that all support https),
    you also need  to assign on or more 'subjectAltName's.
    
      > commonName          = www.argoonics.no
      > 0.subjectAltName    = forum.argoonics.no


    Now the certificate request and the key can be generated:
    
      | $> u-pki org new-req www
      | Generating a 1024 bit RSA private key
      | .......++++++
      | ........++++++
      | writing new private key to 'keys/Argoonics-Foundation_www_20090823_005242.key'
    
    The request is being written to the outgoing/ subdirectory.
    Finally 'u-pki org send' will copy all unsigned requests from
    outgoing/ to the spool directory pointed to by the outbox link:
    
      | $> u-pki org send
      | $>

    One can run 'gen-req' maultiple times on different entities, but
    needs to invoke 'send' only once in a session.
    
    If some time later the certificate expires, only the operations
    'gen-req' and 'send' need to be repeated. This is the rationale
    for the confguration files and the necessity to "create" entities
    first, before issuing requests: The requests can be repeated with
    exactly the same properties, even years later.
    
 
**  Signing keys (CA)
    
    At this moment in time "Argoonics Foundation" has created a
    certificate request and copied it to the spool directory or media.
    
    To produce a valid certificate, the CA "Frobnicate Inc" needs now
    to receive and to sign the certificate request.

    All receiving and signing is done from teh directory containing
    the CA:
    
      | $> cd MyCA/

    The receive command copies all requests from the spool directory
    (defined by the link inbox) into the incoming/ directory.
          
      | $> u-pki ca receive
    
    (This can be repeated multiple times if you use removable media
    and recieve certificate request from multiple sources.)
    
    The operation 'sign-all' will put the "Frobnicate Inc" CA operator
    through interactivly signing all requests.
    
      | $> u-pki ca sign-all
      | 
      | Check that the request matches the signature
      | Signature ok
      | Certificate Details:
      |         Serial Number: 1 (0x1)
      |         Validity
      |             Not Before: Aug 22 23:03:10 2009 GMT
      |             Not After : Aug 20 23:03:10 2019 GMT
      |         Subject:
      |             organizationName          = Argoonics Foundation
      |             commonName                = www.argoonics.no
      |             emailAddress              = info@argoonics.no
      |         X509v3 extensions:
      |             X509v3 Basic Constraints: 
      |                 CA:FALSE
      |             Netscape Comment: 
      |                 OpenSSL Generated Certificate
      |             X509v3 Subject Key Identifier: 
      |                 07:D3:73:06:04:A1:9C:C0:2E:C1:64:D6:9C:64:D2:E7:3A:17:B0:7F
      |             X509v3 Authority Key Identifier: 
      |                 keyid:48:EF:7C:F7:87:12:92:84:AC:DF:43:2C:54:10:97:4A:51:C7:9E:8E
      | 
      | Certificate is to be certified until Aug 20 23:03:10 2019 GMT (3650 days)
      | Sign the certificate? [y/n]:
      | 
      | 1 out of 1 certificate requests certified, commit? [y/n]y
      | Write out database with 1 new entries
      | Data Base Updated
      |
      | $>     

    ...
    
    Note, that this is the moment where the CA operator really needs
    to ask herself wether she is signing the "right" certificate -
    "right" in the sense that the private key of the certificate is
    actually held by the organization that is written in the
    certificate request.
    
    There are various ways to verify this:
    
      - CA and Organization are being operated by the same persons
        (e.g. if a company operates a CA of their own) and the same
        person has generated the key and carried it to the CA using a
        portable medium.
    
      - The CA operator got a portable medium from the requester
        himself and knows that the requester has implemented proper
        handling procedures (e.g. has not left the medium in the
        cafeteria unattended where an attacker could have swapped
        medium or request file)
        
      - The company network infrastructure practically guarantees that
        only authorized and trustworthy personell can copy write to
        the spool directory.
    
      - Call the requester, identify him by his voice and phone number
        and compare fingerprints.
    
    These are only examples and not exhaustive. If the CA operator has
    verified that she indeed got the proper request, she can press 'y'
    to sign the certificate and should also press 'y' to store the
    certificate in the CA certificate database (just for arhival
    purposes and to resend it if the certifacte requester looses the
    cetificate).
    
    After signing all or some of the request (the resulting
    certificates are being written to the outgoing/ directory) one can
    copy all certificates from outgoing/ to the spool directory or
    media defined by the outbox/ link.
    
      | $> u-pki ca ship
      | $>


**    Receiving a certificate (Org)
    
    We are almost complete now. The certificate has been signed, but
    still needs to be recieved by the SSL service provider.
    
    Possibly after mounting the spool media (on which the signed
    certificates get carries or mailed back to him), the "Argoonics
    Foundation" administrator can use 'u-pki org recieve ...' to (a)
    copy certificates on the spool media to the certs/ directory of
    his organisation and remove flag all pending requests as
    completed.
    
      | $> cd MyOrg/
      | mel@daath:~/work/u-pki/unstable/TMP/MyOrg$ 
      | 
      | $> u-pki org receive
      | $>
    
      | $> ls certs/
      | Argoonics-Foundation_www_20090823_005242.crt
      | $>
    
    Note that all certificates and requests get file names composed
    from organization name, service name and a time stamp (of when the
    request was generated). This is not essential to openssl, but
    makes distinguishing and finding requests and certificates in the
    u-pki context much easier.
    
*   Limitations of u-pki    
    --------------------
    
    u-pki has some Limitations, some of which will be removed some
    time in the future and some of which are by design (to keep things
    simple).

**  No CRL handling
    
    There are no commands to generate certificate revokation
    lists. This will change some time in future. (My current use case
    does not integrate key revocation anyway).

**  No Key protection

    Keys are stored in the file system but are not encrypted. You
    should operate organisations and CAs only on encrypted filesystems
    therefore. 
    
    If one wants to keep the CA or organisation direct in a version
    control system (one of my use cases) or back them up, that would
    necessitate encryption of backups and storing the versions control
    system in an encrypted file system too.
    
    Since this can quickly become rather convoluted, a feature to
    encrypt and decrypt keys on the fly is planned (but would use some
    caching, so that the CA needs to be "unlocked" only once per
    session.
    
**  No Protection of CA key against CA operator  
    
    The CA operator can read the key from the CA directory (since all
    operations are performed under his set of rights). In an
    organization where there is a certain turnover at the post of CA
    operator there is therefore the risk, that the operator would copy
    the key and be able to fake certificates long after leaving the
    organisation.
    
    The same, in principle applies to the administrator of the SSL
    service provide with respect to the private keys of the entities.
    
    In future (more likely in the far future) there will be a feature
    for u-pki to hide operations using private keys behind some kind
    of suid/sudo mechanism. This will protect the key from the CA
    operator, though not from the organization IT.
    
    Note, that it is, in principle possible to protect the CA key from
    all protagonists (and still get certificates signed). This
    requires a mixtures of technical measures and implementing
    suitable handling procedures, see section "Paranoid Setup" below.
    

*   Procedures for handling a CA
    ----------------------------
    
    Securing a CA is to a certain extend more a matter of finding and
    implementing the proper handling procedures than of software and
    configuration used.
    
    As already explained, u-pki (being a piece of low cost software)
    has in certain use cases certain drawbacks regarding
    security. Astonishing enough you only need a safe, a proper manual
    of procedures and a bit of cheap hardware to implement a rather
    secure CA.
    
    This is what I'll describe below as the "ultra paranoid setup".    
    
    Since the setup heavily relies on checks and balances between the
    actors (like a bank safe that can only be opened by 2 people
    together), it has a certain "men in black" flair. This might be
    frowned upon in your organization - then you can step down to the
    more pragmatic setups at the price of having to trust your people
    more (which is not necessarily a bad thing).
    
    
**  The ultra paranoid setup
    
*** Preliminaries
    
    Find 2 CA operators (and 2 backup people for them).
    
*** System setup
    
    Buy a cheap notebook. This notebook will carry the CA and never be
    connected to the network.
    
    Install Linux at the notebook, during installation go for whole
    disk encryption (including swap).  Let one operator type the first
    part of the passphrase, the other one the second half. Both should
    keep their passphrase secret from each other and share it with
    their backup.
    
    Move the boot partition to read only media and change booting to
    boot from the read only media. Burn the boot partition on a read
    only medium and get the 2 operators to sign the medium (in a way
    they'll recognize and they think nobody else can imitate).
    
    All setup should be done by two people together, checking each
    other to avoid the system gettng trojaned from the very beginning.
    
    Lock the BIOS by setting a BIOS password. If possible (and if the
    BIOS password can be made belong enough) let one person type the
    first part of the BIOS password and the other person the second
    part.
    
    The CA laptop should normally be kept in the safe.
    
    All this ensures the following:    
    
      - Nobody but the 2 operators (or their backups) together can
        boot the CA notebook.
    
      - Nobody can insert a trojan in the boot medium - it's read
        only, the BIOS is locked (so the attacker can't just change to
        boot from hard disk), the boot medium is signed, so cannot be
        substituted easily.

      - Breaking into the organization's safe and stealing the laptop
        would not compromise the key: The filesystem where it is kept
        is encrypted.

    
*** Signing
    
    Certificates will be signed by copying the certificate requests on
    portable media (e.g. a usb stick), and carrying it to the CA
    notebook, signing them there, copying the back to the USB stick
    and carrying the stick back to whereever the certificates are
    needed.
    
    The handling procedures detailed in the following chapters will
    have to be followed, to take away any opportunity for the CA
    operators to copy the private key of the CA.

    
*** Operational procedures
    
    If the CA is not used for signing certificates, it is to be kept
    in the safe, together with the boot medium. The CA operators
    should not have access to the safe.
    
    If certificates need to be signed, only both operators together
    should be allowed to check out the CA notebook and the boot
    medium. It is suggested that a checkout log is kept with the
    following entries:

      - Date and time of checkout
    
      - Statement which certificates are to be signed today (don't
        allow checkouts without specific purpose).
    
      - Checkbox that integrity of notebook and boot medium has be
        checked.
    
      - Signature of CA operators
      - Signature of person with access to safe
    
      - Date of return of CA into safe
      - Again signatures of CA operators and person with access to safe
    
    Only both operators together can boot the CA (because any of them
    has only half the key for the encrypted file system).
    
    As long as the CA is booted, both operators have to stay at the CA
    and check everything the other operator is entering. Specifically
    they have to ensure that the the other operator will not copy the
    CA key. If one of the operators have to leave the room, the CA has
    to be shut down. If one of the operators has to focus on something
    else (like reading a text, calling senders of certificate
    requests, reading a manual), the other operator must refrain from
    typing anything into the CA and should best keep some visible
    distance from the CA keyboard.

    
*** Backup
    
    For backups, write a script for the CA that encrypts the backup on
    the fly and writes it to removable media. Again every operator
    should supply one half of the pass phrase.
    
    Backups should be kept in the safe (this guards against mishaps
    befalling your CA notebook) and in an external safe or bank vault
    (this guards against your organization headquarters burning down
    or your safe being stolen).

    
**  Pragmatic setups

    The more pragmatic setups just assume that you can trust your CA
    operators (e.g. if you're your own CA operator) and perhaps that
    you can trust your hardware and operating systems that they are
    not trojaned (with a windows operating system that is being used
    to surf the internet this is IMHO a rather tall order, even with
    an anti-virus program and timely updates, but that's your decision
    (and your risk) not mine).
    
    What the pragmatic setups try to do is basically:
    
      - reduce the risk of a stolen laptop / storage medium
    
      - reduce the window of opportunity for the attacker by keeping
        the key encrypted or offline for most of the time.

    
*** Le CA, c'est moi
    
    Put the CA into an encrypted file system image. Only loopback
    mount the image when you need to sign certificates. You can backup
    the image as it is.
    
    Suitable for small teams (down to one) where CA operator and root
    and trustworthy persons are just one and the same. Very suitable
    for a single person operating her/his own CA.
    
    
*** CA on a stick    
    
    Put the CA on a USB stick, link inbox/outbox to a directory on
    your hard drive. Do the same for the organization directory (if
    you also operate SSL services).
    
    Keep the CA stick in the safe. Only insert it in your workstation
    when you need to sign certificates (same aplies to the
    organisation WRT to generating keys and requests).
    
    Suitable: For organisations with low certificate volume,
    trustworthy personell and not so strict security requirements
    (e.g. not on the target list of a secret service and secured
    services are not juicy enough for potential attackers to mount a
    dedicated attack).
    
    This setup also works with cygwin and a windows workstation.
    
